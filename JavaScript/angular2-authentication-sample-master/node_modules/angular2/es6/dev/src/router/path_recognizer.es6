import {assert} from "rtts_assert/rtts_assert";
import {RegExp,
  RegExpWrapper,
  RegExpMatcherWrapper,
  StringWrapper,
  isPresent} from 'angular2/src/facade/lang';
import {Map,
  MapWrapper,
  StringMap,
  StringMapWrapper,
  List,
  ListWrapper} from 'angular2/src/facade/collection';
import {escapeRegex} from './url';
class StaticSegment {
  constructor(string) {
    assert.argumentTypes(string, assert.type.string);
    this.string = string;
    this.name = '';
    this.regex = escapeRegex(string);
  }
  generate(params) {
    return this.string;
  }
}
Object.defineProperty(StaticSegment, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
class DynamicSegment {
  constructor(name) {
    assert.argumentTypes(name, assert.type.string);
    this.name = name;
    this.regex = "([^/]+)";
  }
  generate(params) {
    assert.argumentTypes(params, StringMap);
    return StringMapWrapper.get(params, this.name);
  }
}
Object.defineProperty(DynamicSegment, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
Object.defineProperty(DynamicSegment.prototype.generate, "parameters", {get: function() {
    return [[StringMap]];
  }});
class StarSegment {
  constructor(name) {
    assert.argumentTypes(name, assert.type.string);
    this.name = name;
    this.regex = "(.+)";
  }
  generate(params) {
    assert.argumentTypes(params, StringMap);
    return StringMapWrapper.get(params, this.name);
  }
}
Object.defineProperty(StarSegment, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
Object.defineProperty(StarSegment.prototype.generate, "parameters", {get: function() {
    return [[StringMap]];
  }});
var paramMatcher = RegExpWrapper.create("^:([^\/]+)$");
var wildcardMatcher = RegExpWrapper.create("^\\*([^\/]+)$");
function parsePathString(route) {
  assert.argumentTypes(route, assert.type.string);
  if (route[0] === "/") {
    route = StringWrapper.substring(route, 1);
  }
  var segments = splitBySlash(route);
  var results = ListWrapper.create();
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i],
        match;
    if (isPresent(match = RegExpWrapper.firstMatch(paramMatcher, segment))) {
      ListWrapper.push(results, new DynamicSegment(match[1]));
    } else if (isPresent(match = RegExpWrapper.firstMatch(wildcardMatcher, segment))) {
      ListWrapper.push(results, new StarSegment(match[1]));
    } else if (segment.length > 0) {
      ListWrapper.push(results, new StaticSegment(segment));
    }
  }
  return assert.returnType((results), List);
}
Object.defineProperty(parsePathString, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
var SLASH_RE = RegExpWrapper.create('/');
function splitBySlash(url) {
  assert.argumentTypes(url, assert.type.string);
  return assert.returnType((StringWrapper.split(url, SLASH_RE)), assert.genericType(List, assert.type.string));
}
Object.defineProperty(splitBySlash, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
export class PathRecognizer {
  constructor(path, handler) {
    assert.argumentTypes(path, assert.type.string, handler, assert.type.any);
    this.handler = handler;
    this.segments = ListWrapper.create();
    var segments = parsePathString(path);
    var regexString = '^';
    ListWrapper.forEach(segments, (segment) => {
      regexString += '/' + segment.regex;
    });
    this.regex = RegExpWrapper.create(regexString);
    this.segments = segments;
  }
  parseParams(url) {
    assert.argumentTypes(url, assert.type.string);
    var params = StringMapWrapper.create();
    var urlPart = url;
    for (var i = 0; i < this.segments.length; i++) {
      var segment = this.segments[i];
      var match = RegExpWrapper.firstMatch(RegExpWrapper.create('/' + segment.regex), urlPart);
      urlPart = StringWrapper.substring(urlPart, match[0].length);
      if (segment.name.length > 0) {
        StringMapWrapper.set(params, segment.name, match[1]);
      }
    }
    return assert.returnType((params), StringMap);
  }
  generate(params) {
    return assert.returnType((ListWrapper.join(ListWrapper.map(this.segments, (segment) => '/' + segment.generate(params)), '')), assert.type.string);
  }
}
Object.defineProperty(PathRecognizer, "parameters", {get: function() {
    return [[assert.type.string], [assert.type.any]];
  }});
Object.defineProperty(PathRecognizer.prototype.parseParams, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
Object.defineProperty(PathRecognizer.prototype.generate, "parameters", {get: function() {
    return [[StringMap]];
  }});
//# sourceMappingURL=path_recognizer.js.map

//# sourceMappingURL=./path_recognizer.map