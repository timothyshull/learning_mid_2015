import {assert} from "rtts_assert/rtts_assert";
import {Promise,
  PromiseWrapper,
  EventEmitter,
  ObservableWrapper} from 'angular2/src/facade/async';
import {Map,
  MapWrapper,
  List,
  ListWrapper} from 'angular2/src/facade/collection';
import {isBlank} from 'angular2/src/facade/lang';
import {RouteRegistry} from './route_registry';
import {Pipeline} from './pipeline';
import {Instruction} from './instruction';
import {RouterOutlet} from './router_outlet';
export class Router {
  constructor(registry, pipeline, parent = null, name = '/') {
    assert.argumentTypes(registry, RouteRegistry, pipeline, Pipeline, parent, Router, name, assert.type.any);
    this.name = name;
    this.navigating = false;
    this.parent = parent;
    this.previousUrl = null;
    this._outlets = MapWrapper.create();
    this._children = MapWrapper.create();
    this._registry = registry;
    this._pipeline = pipeline;
    this._subject = new EventEmitter();
  }
  childRouter(outletName = 'default') {
    if (!MapWrapper.contains(this._children, outletName)) {
      MapWrapper.set(this._children, outletName, new ChildRouter(this, outletName));
    }
    return MapWrapper.get(this._children, outletName);
  }
  registerOutlet(outlet, name = 'default') {
    assert.argumentTypes(outlet, RouterOutlet, name, assert.type.any);
    MapWrapper.set(this._outlets, name, outlet);
    return assert.returnType((this.renavigate()), Promise);
  }
  config(path, component, alias = null) {
    assert.argumentTypes(path, assert.type.string, component, assert.type.any, alias, assert.type.string);
    this._registry.config(this.name, path, component, alias);
    return this.renavigate();
  }
  navigate(url) {
    if (this.navigating) {
      return assert.returnType((PromiseWrapper.resolve(true)), Promise);
    }
    this.lastNavigationAttempt = url;
    var instruction = this.recognize(url);
    if (isBlank(instruction)) {
      return assert.returnType((PromiseWrapper.resolve(false)), Promise);
    }
    instruction.router = this;
    this._startNavigating();
    var result = this._pipeline.process(instruction).then((_) => {
      ObservableWrapper.callNext(this._subject, instruction.matchedUrl);
    }).then((_) => this._finishNavigating());
    PromiseWrapper.catchError(result, (_) => this._finishNavigating());
    return assert.returnType((result), Promise);
  }
  _startNavigating() {
    this.navigating = true;
  }
  _finishNavigating() {
    this.navigating = false;
  }
  subscribe(onNext) {
    ObservableWrapper.subscribe(this._subject, onNext);
  }
  activateOutlets(instruction) {
    return assert.returnType((this._queryOutlets((outlet, name) => {
      return outlet.activate(instruction.getChildInstruction(name));
    }).then((_) => instruction.mapChildrenAsync((instruction, _) => {
      return instruction.router.activateOutlets(instruction);
    }))), Promise);
  }
  traverseOutlets(fn) {
    return assert.returnType((this._queryOutlets(fn).then((_) => mapObjAsync(this._children, (child, _) => child.traverseOutlets(fn)))), Promise);
  }
  _queryOutlets(fn) {
    return assert.returnType((mapObjAsync(this._outlets, fn)), Promise);
  }
  recognize(url) {
    assert.argumentTypes(url, assert.type.string);
    return this._registry.recognize(url);
  }
  renavigate() {
    var destination = isBlank(this.previousUrl) ? this.lastNavigationAttempt : this.previousUrl;
    if (this.navigating || isBlank(destination)) {
      return assert.returnType((PromiseWrapper.resolve(false)), Promise);
    }
    return assert.returnType((this.navigate(destination)), Promise);
  }
  generate(name, params) {
    assert.argumentTypes(name, assert.type.string, params, assert.type.any);
    return this._registry.generate(name, params);
  }
  static getRoot() {
    return assert.returnType((new RootRouter(new Pipeline())), Router);
  }
}
Object.defineProperty(Router, "parameters", {get: function() {
    return [[RouteRegistry], [Pipeline], [Router], []];
  }});
Object.defineProperty(Router.prototype.registerOutlet, "parameters", {get: function() {
    return [[RouterOutlet], []];
  }});
Object.defineProperty(Router.prototype.config, "parameters", {get: function() {
    return [[assert.type.string], [], [assert.type.string]];
  }});
Object.defineProperty(Router.prototype.navigate, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
Object.defineProperty(Router.prototype.activateOutlets, "parameters", {get: function() {
    return [[Instruction]];
  }});
Object.defineProperty(Router.prototype.recognize, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
Object.defineProperty(Router.prototype.generate, "parameters", {get: function() {
    return [[assert.type.string], [assert.type.any]];
  }});
export class RootRouter extends Router {
  constructor(pipeline) {
    assert.argumentTypes(pipeline, Pipeline);
    super(new RouteRegistry(), pipeline, null, '/');
  }
}
Object.defineProperty(RootRouter, "parameters", {get: function() {
    return [[Pipeline]];
  }});
class ChildRouter extends Router {
  constructor(parent, name) {
    super(parent._registry, parent._pipeline, parent, name);
    this.parent = parent;
  }
}
function mapObjAsync(obj, fn) {
  assert.argumentTypes(obj, Map, fn, assert.type.any);
  return PromiseWrapper.all(mapObj(obj, fn));
}
Object.defineProperty(mapObjAsync, "parameters", {get: function() {
    return [[Map], []];
  }});
function mapObj(obj, fn) {
  var result = ListWrapper.create();
  MapWrapper.forEach(obj, (value, key) => ListWrapper.push(result, fn(value, key)));
  return assert.returnType((result), List);
}
Object.defineProperty(mapObj, "parameters", {get: function() {
    return [[Map], []];
  }});
//# sourceMappingURL=router.js.map

//# sourceMappingURL=./router.map