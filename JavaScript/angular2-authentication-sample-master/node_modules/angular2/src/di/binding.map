{"version":3,"sources":["binding.js"],"names":[],"mappings":"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","file":"angular2/src/di/binding.js","sourcesContent":["import {Type, isBlank, isPresent, CONST} from 'angular2/src/facade/lang';\nimport {List, MapWrapper, ListWrapper} from 'angular2/src/facade/collection';\nimport {reflector} from 'angular2/src/reflection/reflection';\nimport {Key} from './key';\nimport {Inject, InjectLazy, InjectPromise, Optional, DependencyAnnotation} from './annotations';\nimport {NoAnnotationError} from './exceptions';\n\n/**\n * @private\n */\nexport class Dependency {\n  key:Key;\n  asPromise:boolean;\n  lazy:boolean;\n  optional:boolean;\n  properties:List;\n\n  constructor(key:Key, asPromise:boolean, lazy:boolean, optional:boolean, properties:List) {\n    this.key = key;\n    this.asPromise = asPromise;\n    this.lazy = lazy;\n    this.optional = optional;\n    this.properties = properties;\n  }\n\n  static fromKey(key:Key) {\n    return new Dependency(key, false, false, false, []);\n  }\n}\n\nvar _EMPTY_LIST = [];  // TODO: make const when supported\n\n/**\n * Describes how the {@link Injector} should instantiate a given token.\n *\n * See {@link bind}.\n *\n * ## Example\n *\n * ```javascript\n * var injector = Injector.resolveAndCreate([\n *   new Binding(String, { toValue: 'Hello' })\n * ]);\n *\n * expect(injector.get(String)).toEqual('Hello');\n * ```\n *\n * @exportedAs angular2/di\n */\nexport class Binding {\n\n  /**\n   * Token used when retrieving this binding. Usually the `Type`.\n   */\n  token;\n\n  /**\n   * Binds an interface to an implementation / subclass.\n   *\n   * ## Example\n   *\n   * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy comparison.\n   *\n   * ```javascript\n   *\n   * class Vehicle {}\n   *\n   * class Car extends Vehicle {}\n   *\n   * var injectorClass = Injector.resolveAndCreate([\n   *   Car,\n   *   new Binding(Vehicle, { toClass: Car })\n   * ]);\n   * var injectorAlias = Injector.resolveAndCreate([\n   *   Car,\n   *   new Binding(Vehicle, { toAlias: Car })\n   * ]);\n   *\n   * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n   * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n   *\n   * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n   * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n   * ```\n   */\n  toClass:Type;\n\n  /**\n   * Binds a key to a value.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   new Binding(String, { toValue: 'Hello' })\n   * ]);\n   *\n   * expect(injector.get(String)).toEqual('Hello');\n   * ```\n   */\n  toValue;\n\n  /**\n   * Binds a key to the alias for an existing key.\n   *\n   * An alias means that {@link Injector} returns the same instance as if the alias token was used. This is in contrast to\n   * `toClass` where a separate instance of `toClass` is returned.\n   *\n   * ## Example\n   *\n   * Becuse `toAlias` and `toClass` are often confused the example contains both use cases for easy comparison.\n   *\n   * ```javascript\n   *\n   * class Vehicle {}\n   *\n   * class Car extends Vehicle {}\n   *\n   * var injectorAlias = Injector.resolveAndCreate([\n   *   Car,\n   *   new Binding(Vehicle, { toAlias: Car })\n   * ]);\n   * var injectorClass = Injector.resolveAndCreate([\n   *   Car,\n   *   new Binding(Vehicle, { toClass: Car })\n   * ]);\n   *\n   * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n   * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n   *\n   * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n   * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n   * ```\n   */\n  toAlias;\n\n  /**\n   * Binds a key to a function which computes the value.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n   *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n   *                         dependencies: [String] })\n   * ]);\n   *\n   * expect(injector.get(Number)).toEqual(3);\n   * expect(injector.get(String)).toEqual('Value: 3');\n   * ```\n   */\n  toFactory:Function;\n\n  /**\n   * Binds a key to a function which computes the value asynchronously.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   new Binding(Number, { toAsyncFactory: () => {\n   *     return new Promise((resolve) => resolve(1 + 2));\n   *   }}),\n   *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n   *                         dependencies: [String]})\n   * ]);\n   *\n   * injector.asyncGet(Number).then((v) => expect(v).toBe(3));\n   * injector.asyncGet(String).then((v) => expect(v).toBe('Value: 3'));\n   * ```\n   *\n   * The interesting thing to note is that event though `Number` has an async factory, the `String` factory\n   * function takes the resolved value. This shows that the {@link Injector} delays executing the `String` factory\n   * until after the `Number` is resolved. This can only be done if the `token` is retrieved using the\n   * `asyncGet` API in the {@link Injector}.\n   *\n   */\n  toAsyncFactory:Function;\n\n  /**\n   * Used in conjunction with `toFactory` or `toAsyncFactory` and specifies a set of dependencies (as `token`s) which\n   * should be injected into the factory function.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n   *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n   *                         dependencies: [String] })\n   * ]);\n   *\n   * expect(injector.get(Number)).toEqual(3);\n   * expect(injector.get(String)).toEqual('Value: 3');\n   * ```\n   */\n  dependencies:List;\n\n  @CONST()\n  constructor(\n      token,\n      {\n        toClass,\n        toValue,\n        toAlias,\n        toFactory,\n        toAsyncFactory,\n        deps\n      }) {\n    this.token = token;\n    this.toClass = toClass;\n    this.toValue = toValue;\n    this.toAlias = toAlias;\n    this.toFactory = toFactory;\n    this.toAsyncFactory = toAsyncFactory;\n    this.dependencies = deps;\n  }\n\n  /**\n   * Converts the {@link Binding} into {@link ResolvedBinding}.\n   *\n   * {@link Injector} internally only uses {@link ResolvedBinding}, {@link Binding} contains convenience binding syntax.\n   */\n  resolve(): ResolvedBinding {\n    var factoryFn:Function;\n    var resolvedDeps;\n    var isAsync = false;\n    if (isPresent(this.toClass)) {\n      factoryFn = reflector.factory(this.toClass);\n      resolvedDeps = _dependenciesFor(this.toClass);\n    } else if (isPresent(this.toAlias)) {\n      factoryFn = (aliasInstance) => aliasInstance;\n      resolvedDeps = [Dependency.fromKey(Key.get(this.toAlias))];\n    } else if (isPresent(this.toFactory)) {\n      factoryFn = this.toFactory;\n      resolvedDeps = _constructDependencies(this.toFactory, this.dependencies);\n    } else if (isPresent(this.toAsyncFactory)) {\n      factoryFn = this.toAsyncFactory;\n      resolvedDeps = _constructDependencies(this.toAsyncFactory, this.dependencies);\n      isAsync = true;\n    } else {\n      factoryFn = () => this.toValue;\n      resolvedDeps = _EMPTY_LIST;\n    }\n\n    return new ResolvedBinding(\n      Key.get(this.token),\n      factoryFn,\n      resolvedDeps,\n      isAsync\n    );\n  }\n}\n\n/**\n * An internal resolved representation of a {@link Binding} used by the {@link Injector}.\n *\n * A {@link Binding} is resolved when it has a factory function. Binding to a class, alias, or value, are just convenience\n * methods, as {@link Injector} only operates on calling factory functions.\n *\n * @exportedAs angular2/di\n */\nexport class ResolvedBinding {\n  /**\n   * A key, usually a `Type`.\n   */\n  key:Key;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  factory:Function;\n\n  /**\n   * Arguments (dependencies) to the `factory` function.\n   */\n  dependencies:List<Dependency>;\n\n  /**\n   * Specifies whether the `factory` function returns a `Promise`.\n   */\n  providedAsPromise:boolean;\n\n  constructor(key:Key, factory:Function, dependencies:List<Dependency>, providedAsPromise:boolean) {\n    this.key = key;\n    this.factory = factory;\n    this.dependencies = dependencies;\n    this.providedAsPromise = providedAsPromise;\n  }\n}\n\n/**\n * Provides an API for imperatively constructing {@link Binding}s.\n *\n * This is only relevant for JavaScript. See {@link BindingBuilder}.\n *\n * ## Example\n *\n * ```javascript\n * bind(MyInterface).toClass(MyClass)\n *\n * ```\n *\n * @exportedAs angular2/di\n */\nexport function bind(token):BindingBuilder {\n  return new BindingBuilder(token);\n}\n\n/**\n * Helper class for the {@link bind} function.\n *\n * @exportedAs angular2/di\n */\nexport class BindingBuilder {\n  token;\n\n  constructor(token) {\n    this.token = token;\n  }\n\n  /**\n   * Binds an interface to an implementation / subclass.\n   *\n   * ## Example\n   *\n   * Because `toAlias` and `toClass` are often confused, the example contains both use cases for easy comparison.\n   *\n   * ```javascript\n   *\n   * class Vehicle {}\n   *\n   * class Car extends Vehicle {}\n   *\n   * var injectorClass = Injector.resolveAndCreate([\n   *   Car,\n   *   bind(Vehicle).toClass(Car)\n   * ]);\n   * var injectorAlias = Injector.resolveAndCreate([\n   *   Car,\n   *   bind(Vehicle).toAlias(Car)\n   * ]);\n   *\n   * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n   * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n   *\n   * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n   * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n   * ```\n   */\n  toClass(type:Type):Binding {\n    return new Binding(this.token, {toClass: type});\n  }\n\n  /**\n   * Binds a key to a value.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   bind(String).toValue('Hello')\n   * ]);\n   *\n   * expect(injector.get(String)).toEqual('Hello');\n   * ```\n   */\n  toValue(value):Binding {\n    return new Binding(this.token, {toValue: value});\n  }\n\n  /**\n   * Binds a key to the alias for an existing key.\n   *\n   * An alias means that we will return the same instance as if the alias token was used. (This is in contrast to\n   * `toClass` where a separet instance of `toClass` will be returned.)\n   *\n   * ## Example\n   *\n   * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy comparison.\n   *\n   * ```javascript\n   *\n   * class Vehicle {}\n   *\n   * class Car extends Vehicle {}\n   *\n   * var injectorAlias = Injector.resolveAndCreate([\n   *   Car,\n   *   bind(Vehicle).toAlias(Car)\n   * ]);\n   * var injectorClass = Injector.resolveAndCreate([\n   *   Car,\n   *   bind(Vehicle).toClass(Car)\n   * ]);\n   *\n   * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n   * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n   *\n   * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n   * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n   * ```\n   */\n  toAlias(aliasToken):Binding {\n    return new Binding(this.token, {toAlias: aliasToken});\n  }\n\n  /**\n   * Binds a key to a function which computes the value.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   bind(Number).toFactory(() => { return 1+2; }}),\n   *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [String] })\n   * ]);\n   *\n   * expect(injector.get(Number)).toEqual(3);\n   * expect(injector.get(String)).toEqual('Value: 3');\n   * ```\n   */\n  toFactory(factoryFunction:Function, dependencies:List = null):Binding {\n    return new Binding(this.token, {\n      toFactory: factoryFunction,\n      deps: dependencies\n    });\n  }\n\n  /**\n   * Binds a key to a function which computes the value asynchronously.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   bind(Number).toAsyncFactory(() => {\n   *     return new Promise((resolve) => resolve(1 + 2));\n   *   }),\n   *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [String])\n   * ]);\n   *\n   * injector.asyncGet(Number).then((v) => expect(v).toBe(3));\n   * injector.asyncGet(String).then((v) => expect(v).toBe('Value: 3'));\n   * ```\n   *\n   * The interesting thing to note is that event though `Number` has an async factory, the `String` factory\n   * function takes the resolved value. This shows that the {@link Injector} delays executing of the `String` factory\n   * until after the `Number` is resolved. This can only be done if the `token` is retrieved using the\n   * the `asyncGet` API in the {@link Injector}.\n   */\n  toAsyncFactory(factoryFunction:Function, dependencies:List = null):Binding {\n    return new Binding(this.token, {\n      toAsyncFactory: factoryFunction,\n      deps: dependencies\n    });\n  }\n}\n\nfunction _constructDependencies(factoryFunction:Function, dependencies:List) {\n  return isBlank(dependencies) ?\n    _dependenciesFor(factoryFunction) :\n    ListWrapper.map(dependencies, (t) => Dependency.fromKey(Key.get(t)));\n}\n\nfunction _dependenciesFor(typeOrFunc):List {\n  var params = reflector.parameters(typeOrFunc);\n  if (isBlank(params)) return [];\n  if (ListWrapper.any(params, (p) => isBlank(p))) throw new NoAnnotationError(typeOrFunc);\n  return ListWrapper.map(params, (p) => _extractToken(typeOrFunc, p));\n}\n\nfunction _extractToken(typeOrFunc, annotations) {\n  var depProps = [];\n  var token = null;\n  var optional = false;\n  var lazy = false;\n  var asPromise = false;\n\n  for (var i = 0; i < annotations.length; ++i) {\n    var paramAnnotation = annotations[i];\n\n    if (paramAnnotation instanceof Type) {\n      token = paramAnnotation;\n\n    } else if (paramAnnotation instanceof Inject) {\n      token = paramAnnotation.token;\n\n    } else if (paramAnnotation instanceof InjectPromise) {\n      token = paramAnnotation.token;\n      asPromise = true;\n\n    } else if (paramAnnotation instanceof InjectLazy) {\n      token = paramAnnotation.token;\n      lazy = true;\n\n    } else if (paramAnnotation instanceof Optional) {\n      optional = true;\n\n    } else if (paramAnnotation instanceof DependencyAnnotation) {\n      if (isPresent(paramAnnotation.token)) {\n       token = paramAnnotation.token;\n      }\n      ListWrapper.push(depProps, paramAnnotation);\n\n    }\n  }\n\n  if (isPresent(token)) {\n    return _createDependency(token, asPromise, lazy, optional, depProps);\n  } else {\n    throw new NoAnnotationError(typeOrFunc);\n  }\n}\n\nfunction _createDependency(token, asPromise, lazy, optional, depProps):Dependency {\n  return new Dependency(Key.get(token), asPromise, lazy, optional, depProps);\n}\n"]}